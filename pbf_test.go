package pbf

import (
	"encoding/binary"
	"testing"
)

var uint32e = []byte{0xa9, 0x1, 0x0, 0xfb, 0xfe, 0x6, 0x1, 0x1, 0x2, 0x1f, 0x3, 0xfc, 0xfe, 0x6, 0x4, 0xfd, 0xfe, 0x6, 0x5, 0xfe, 0xfe, 0x6, 0x6, 0xff, 0xfe, 0x6, 0x1b, 0xeb, 0xba, 0x4, 0x29, 0x80, 0xff, 0x6, 0xcc, 0x1, 0x81, 0xff, 0x6, 0x7, 0x82, 0xff, 0x6, 0x8, 0xe1, 0xf6, 0x6, 0xcd, 0x1, 0xe9, 0x2, 0xa1, 0x1, 0xf6, 0x4, 0xc9, 0x1, 0x83, 0xff, 0x6, 0x47, 0xa1, 0xc, 0xce, 0x1, 0x6b, 0x11, 0x84, 0xff, 0x6, 0xcf, 0x1, 0x85, 0xff, 0x6, 0x49, 0xe6, 0x6, 0xd0, 0x1, 0x86, 0xff, 0x6, 0x4b, 0x87, 0xff, 0x6, 0x61, 0x88, 0xff, 0x6, 0xd1, 0x1, 0x89, 0xff, 0x6, 0x51, 0xa0, 0xc, 0x62, 0xdb, 0x18, 0xd2, 0x1, 0x8a, 0xff, 0x6, 0x63, 0xdc, 0x18, 0xd3, 0x1, 0x8b, 0xff, 0x6, 0xd4, 0x1, 0x8c, 0xff, 0x6, 0x52, 0x8d, 0xff, 0x6, 0x4c, 0x8e, 0xff, 0x6, 0xd5, 0x1, 0x8f, 0xff, 0x6, 0xd6, 0x1, 0xb1, 0xc1, 0x3, 0xd7, 0x1, 0xe6, 0x6, 0xd8, 0x1, 0x90, 0xff, 0x6, 0xd9, 0x1, 0x91, 0xff, 0x6, 0xda, 0x1, 0x92, 0xff, 0x6, 0xdb, 0x1, 0x93, 0xff, 0x6, 0xdc, 0x1, 0xe4, 0x3, 0xdd, 0x1, 0xde, 0xcc, 0x2, 0xa9, 0x1, 0x0, 0xfb, 0xfe, 0x6, 0x1, 0x1, 0x2, 0x1f, 0x3, 0xfc, 0xfe, 0x6, 0x4, 0xfd, 0xfe, 0x6, 0x5, 0xfe, 0xfe, 0x6, 0x6, 0xff, 0xfe, 0x6, 0x1b, 0xeb, 0xba, 0x4, 0x29, 0x80, 0xff, 0x6, 0xcc, 0x1, 0x81, 0xff, 0x6, 0x7, 0x82, 0xff, 0x6, 0x8, 0xe1, 0xf6, 0x6, 0xcd, 0x1, 0xe9, 0x2, 0xa1, 0x1, 0xf6, 0x4, 0xc9, 0x1, 0x83, 0xff, 0x6, 0x47, 0xa1, 0xc, 0xce, 0x1, 0x6b, 0x11, 0x84, 0xff, 0x6, 0xcf, 0x1, 0x85, 0xff, 0x6, 0x49, 0xe6, 0x6, 0xd0, 0x1, 0x86, 0xff, 0x6, 0x4b, 0x87, 0xff, 0x6, 0x61, 0x88, 0xff, 0x6, 0xd1, 0x1, 0x89, 0xff, 0x6, 0x51, 0xa0, 0xc, 0x62, 0xdb, 0x18, 0xd2, 0x1, 0x8a, 0xff, 0x6, 0x63, 0xdc, 0x18, 0xd3, 0x1, 0x8b, 0xff, 0x6, 0xd4, 0x1, 0x8c, 0xff, 0x6, 0x52, 0x8d, 0xff, 0x6, 0x4c, 0x8e, 0xff, 0x6, 0xd5, 0x1, 0x8f, 0xff, 0x6, 0xd6, 0x1, 0xb1, 0xc1, 0x3, 0xd7, 0x1, 0xe6, 0x6, 0xd8, 0x1, 0x90, 0xff, 0x6, 0xd9, 0x1, 0x91, 0xff, 0x6, 0xda, 0x1, 0x92, 0xff, 0x6, 0xdb, 0x1, 0x93, 0xff, 0x6, 0xdc, 0x1, 0xe4, 0x3, 0xdd, 0x1, 0xde, 0xcc, 0x2, 0xa9, 0x1, 0x0, 0xfb, 0xfe, 0x6, 0x1, 0x1, 0x2, 0x1f, 0x3, 0xfc, 0xfe, 0x6, 0x4, 0xfd, 0xfe, 0x6, 0x5, 0xfe, 0xfe, 0x6, 0x6, 0xff, 0xfe, 0x6, 0x1b, 0xeb, 0xba, 0x4, 0x29, 0x80, 0xff, 0x6, 0xcc, 0x1, 0x81, 0xff, 0x6, 0x7, 0x82, 0xff, 0x6, 0x8, 0xe1, 0xf6, 0x6, 0xcd, 0x1, 0xe9, 0x2, 0xa1, 0x1, 0xf6, 0x4, 0xc9, 0x1, 0x83, 0xff, 0x6, 0x47, 0xa1, 0xc, 0xce, 0x1, 0x6b, 0x11, 0x84, 0xff, 0x6, 0xcf, 0x1, 0x85, 0xff, 0x6, 0x49, 0xe6, 0x6, 0xd0, 0x1, 0x86, 0xff, 0x6, 0x4b, 0x87, 0xff, 0x6, 0x61, 0x88, 0xff, 0x6, 0xd1, 0x1, 0x89, 0xff, 0x6, 0x51, 0xa0, 0xc, 0x62, 0xdb, 0x18, 0xd2, 0x1, 0x8a, 0xff, 0x6, 0x63, 0xdc, 0x18, 0xd3, 0x1, 0x8b, 0xff, 0x6, 0xd4, 0x1, 0x8c, 0xff, 0x6, 0x52, 0x8d, 0xff, 0x6, 0x4c, 0x8e, 0xff, 0x6, 0xd5, 0x1, 0x8f, 0xff, 0x6, 0xd6, 0x1, 0xb1, 0xc1, 0x3, 0xd7, 0x1, 0xe6, 0x6, 0xd8, 0x1, 0x90, 0xff, 0x6, 0xd9, 0x1, 0x91, 0xff, 0x6, 0xda, 0x1, 0x92, 0xff, 0x6, 0xdb, 0x1, 0x93, 0xff, 0x6, 0xdc, 0x1, 0xe4, 0x3, 0xdd, 0x1, 0xde, 0xcc, 0x2, 0xa9, 0x1, 0x0, 0xfb, 0xfe, 0x6, 0x1, 0x1, 0x2, 0x1f, 0x3, 0xfc, 0xfe, 0x6, 0x4, 0xfd, 0xfe, 0x6, 0x5, 0xfe, 0xfe, 0x6, 0x6, 0xff, 0xfe, 0x6, 0x1b, 0xeb, 0xba, 0x4, 0x29, 0x80, 0xff, 0x6, 0xcc, 0x1, 0x81, 0xff, 0x6, 0x7, 0x82, 0xff, 0x6, 0x8, 0xe1, 0xf6, 0x6, 0xcd, 0x1, 0xe9, 0x2, 0xa1, 0x1, 0xf6, 0x4, 0xc9, 0x1, 0x83, 0xff, 0x6, 0x47, 0xa1, 0xc, 0xce, 0x1, 0x6b, 0x11, 0x84, 0xff, 0x6, 0xcf, 0x1, 0x85, 0xff, 0x6, 0x49, 0xe6, 0x6, 0xd0, 0x1, 0x86, 0xff, 0x6, 0x4b, 0x87, 0xff, 0x6, 0x61, 0x88, 0xff, 0x6, 0xd1, 0x1, 0x89, 0xff, 0x6, 0x51, 0xa0, 0xc, 0x62, 0xdb, 0x18, 0xd2, 0x1, 0x8a, 0xff, 0x6, 0x63, 0xdc, 0x18, 0xd3, 0x1, 0x8b, 0xff, 0x6, 0xd4, 0x1, 0x8c, 0xff, 0x6, 0x52, 0x8d, 0xff, 0x6, 0x4c, 0x8e, 0xff, 0x6, 0xd5, 0x1, 0x8f, 0xff, 0x6, 0xd6, 0x1, 0xb1, 0xc1, 0x3, 0xd7, 0x1, 0xe6, 0x6, 0xd8, 0x1, 0x90, 0xff, 0x6, 0xd9, 0x1, 0x91, 0xff, 0x6, 0xda, 0x1, 0x92, 0xff, 0x6, 0xdb, 0x1, 0x93, 0xff, 0x6, 0xdc, 0x1, 0xe4, 0x3, 0xdd, 0x1, 0xde, 0xcc, 0x2, 0xa9, 0x1, 0x0, 0xfb, 0xfe, 0x6, 0x1, 0x1, 0x2, 0x1f, 0x3, 0xfc, 0xfe, 0x6, 0x4, 0xfd, 0xfe, 0x6, 0x5, 0xfe, 0xfe, 0x6, 0x6, 0xff, 0xfe, 0x6, 0x1b, 0xeb, 0xba, 0x4, 0x29, 0x80, 0xff, 0x6, 0xcc, 0x1, 0x81, 0xff, 0x6, 0x7, 0x82, 0xff, 0x6, 0x8, 0xe1, 0xf6, 0x6, 0xcd, 0x1, 0xe9, 0x2, 0xa1, 0x1, 0xf6, 0x4, 0xc9, 0x1, 0x83, 0xff, 0x6, 0x47, 0xa1, 0xc, 0xce, 0x1, 0x6b, 0x11, 0x84, 0xff, 0x6, 0xcf, 0x1, 0x85, 0xff, 0x6, 0x49, 0xe6, 0x6, 0xd0, 0x1, 0x86, 0xff, 0x6, 0x4b, 0x87, 0xff, 0x6, 0x61, 0x88, 0xff, 0x6, 0xd1, 0x1, 0x89, 0xff, 0x6, 0x51, 0xa0, 0xc, 0x62, 0xdb, 0x18, 0xd2, 0x1, 0x8a, 0xff, 0x6, 0x63, 0xdc, 0x18, 0xd3, 0x1, 0x8b, 0xff, 0x6, 0xd4, 0x1, 0x8c, 0xff, 0x6, 0x52, 0x8d, 0xff, 0x6, 0x4c, 0x8e, 0xff, 0x6, 0xd5, 0x1, 0x8f, 0xff, 0x6, 0xd6, 0x1, 0xb1, 0xc1, 0x3, 0xd7, 0x1, 0xe6, 0x6, 0xd8, 0x1, 0x90, 0xff, 0x6, 0xd9, 0x1, 0x91, 0xff, 0x6, 0xda, 0x1, 0x92, 0xff, 0x6, 0xdb, 0x1, 0x93, 0xff, 0x6, 0xdc, 0x1, 0xe4, 0x3, 0xdd, 0x1, 0xde, 0xcc, 0x2, 0xa9, 0x1, 0x0, 0xfb, 0xfe, 0x6, 0x1, 0x1, 0x2, 0x1f, 0x3, 0xfc, 0xfe, 0x6, 0x4, 0xfd, 0xfe, 0x6, 0x5, 0xfe, 0xfe, 0x6, 0x6, 0xff, 0xfe, 0x6, 0x1b, 0xeb, 0xba, 0x4, 0x29, 0x80, 0xff, 0x6, 0xcc, 0x1, 0x81, 0xff, 0x6, 0x7, 0x82, 0xff, 0x6, 0x8, 0xe1, 0xf6, 0x6, 0xcd, 0x1, 0xe9, 0x2, 0xa1, 0x1, 0xf6, 0x4, 0xc9, 0x1, 0x83, 0xff, 0x6, 0x47, 0xa1, 0xc, 0xce, 0x1, 0x6b, 0x11, 0x84, 0xff, 0x6, 0xcf, 0x1, 0x85, 0xff, 0x6, 0x49, 0xe6, 0x6, 0xd0, 0x1, 0x86, 0xff, 0x6, 0x4b, 0x87, 0xff, 0x6, 0x61, 0x88, 0xff, 0x6, 0xd1, 0x1, 0x89, 0xff, 0x6, 0x51, 0xa0, 0xc, 0x62, 0xdb, 0x18, 0xd2, 0x1, 0x8a, 0xff, 0x6, 0x63, 0xdc, 0x18, 0xd3, 0x1, 0x8b, 0xff, 0x6, 0xd4, 0x1, 0x8c, 0xff, 0x6, 0x52, 0x8d, 0xff, 0x6, 0x4c, 0x8e, 0xff, 0x6, 0xd5, 0x1, 0x8f, 0xff, 0x6, 0xd6, 0x1, 0xb1, 0xc1, 0x3, 0xd7, 0x1, 0xe6, 0x6, 0xd8, 0x1, 0x90, 0xff, 0x6, 0xd9, 0x1, 0x91, 0xff, 0x6, 0xda, 0x1, 0x92, 0xff, 0x6, 0xdb, 0x1, 0x93, 0xff, 0x6, 0xdc, 0x1, 0xe4, 0x3, 0xdd, 0x1, 0xde, 0xcc, 0x2}
var pbfval = Reader{Pbf: uint32e, Length: len(uint32e)}

func TestDecodeVarint(t *testing.T) {
	expected := uint64(3234230423)

	b := make([]byte, 8)
	n := binary.PutUvarint(b, uint64(expected))
	b = b[:n]
	val := DecodeVarint(b)

	if val != expected {
		t.Errorf("DecodeVarint %d expected got %d", expected, val)
	}
}

func TestKey(t *testing.T) {
	e_k, e_t := byte(3), byte(2)
	kk, tt := Key(26)

	if kk != e_k || tt != e_t {
		t.Errorf("TestKey %b %b expected got %b %b", e_k, e_t, kk, tt)
	}
}

func TestReadInt32(t *testing.T) {
	expected := int32(33234)

	b := make([]byte, 8)
	binary.LittleEndian.PutUint32(b, uint32(expected))
	val := int32(ReadInt32(b[:2]))

	if val != expected {
		t.Errorf("DecodeVarint %d expected got %d", expected, val)
	}
}

func TestReadUInt32(t *testing.T) {
	expected := uint32(33234)

	b := make([]byte, 8)
	binary.LittleEndian.PutUint32(b, uint32(expected))
	val := uint32(ReadUInt32(b[:2]))

	if val != expected {
		t.Errorf("DecodeVarint %d expected got %d", expected, val)
	}
}

func TestReadInt32_Pbf(t *testing.T) {
	expected := int32(33234)

	b := make([]byte, 8)
	binary.LittleEndian.PutUint32(b, uint32(expected))
	b = append(b, []byte{2, 4}...)
	pbfval := &Reader{Pbf: b, Length: len(b)}

	val := pbfval.ReadInt32()

	if val != expected {
		t.Errorf("DecodeVarint %d expected got %d", expected, val)
	}
}

func TestReadUInt32_Pbf(t *testing.T) {
	expected := uint32(33234)

	b := make([]byte, 8)
	binary.LittleEndian.PutUint32(b, uint32(expected))
	b = append(b, []byte{2, 4}...)
	pbfval := &Reader{Pbf: b, Length: len(b)}

	val := pbfval.ReadUInt32()

	if val != expected {
		t.Errorf("DecodeVarint %d expected got %d", expected, val)
	}
}

func Benchmark_ReadPackedUInt32_Newer(b *testing.B) {
	b.ReportAllocs()

	for n := 0; n < b.N; n++ {
		pbfval.ReadPackedUInt32()
		pbfval.Pos = 0

	}
}

func TestWriteTag(t *testing.T) {
	w := NewWriter()

	w.writeValue(tagAndType(TagType(1), Fixed64))

	if w.Pos != 1 {
		t.FailNow()
	}

	e_k, e_t := byte(1), byte(1)
	kk, tt := Key(w.Pbf[0])

	if kk != e_k || tt != e_t {
		t.Errorf("TestKey %b %b expected got %b %b", e_k, e_t, kk, tt)
	}
}

func TestWriteFixed(t *testing.T) {
	w := NewWriter()
	w.writeFixed32(2)

	if w.Pos != 4 {
		t.FailNow()
	}

	w.writeFixed64(2)

	if w.Pos != 12 {
		t.FailNow()
	}
}

func TestWriteVarint(t *testing.T) {
	w := NewWriter()
	w.writeValue(2)

	if w.Pos != 1 {
		t.FailNow()
	}

	w.writeValue(0x80)

	if w.Pos != 3 {
		t.FailNow()
	}
}

func TestWritePacked(t *testing.T) {
	w := NewWriter()
	except := [4]uint64{0, 255, 4096, 25535}

	w.WritePackedUInt64(TagType(1), except[:])

	buf := w.Finish()

	reader := NewReader(buf)

	tag, v := reader.ReadTag()
	if tag != TagType(1) || v != Bytes {
		t.FailNow()
	}
	ty := reader.ReadPackedUInt64()

	if len(ty) != len(except) {
		t.FailNow()
	}

	for i := range ty {
		if except[i] != ty[i] {
			t.FailNow()
		}
	}
}

func TestWriteString(t *testing.T) {
	w := NewWriter()
	except := "test!!!"

	w.WriteString(TagType(1), except)

	buf := w.Finish()

	reader := NewReader(buf)

	tag, v := reader.ReadTag()
	if tag != TagType(1) || v != Bytes {
		t.FailNow()
	}
	ty := reader.ReadString()

	if ty != except {
		t.FailNow()
	}
}
